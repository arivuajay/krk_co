<?php/** * This is the model class for table "{{user}}". * * The followings are the available columns in table '{{user}}': * @property integer $user_id * @property string $username * @property string $password_hash * @property string $password_reset_token * @property string $first_name * @property string $last_name * @property string $email_id * @property string $mobile_no * @property string $address * @property string $dojoin * @property string $dobirtrh * @property string $authorize * @property string $status * @property string $created_at * @property integer $created_by * @property string $modified_at * @property integer $modified_by */class User extends CActiveRecord {    const USERNAME_NUM_PAD = 4;    const PASSWORD_LENGTH = 8;    public $temp_password;    /**     * @return string the associated database table name     */    public function tableName() {        return '{{user}}';    }    /**     * @return array validation rules for model attributes.     */    public function rules() {        // NOTE: you should only define rules for those attributes that        // will receive user inputs.        return array(            array('first_name, email_id, created_at, created_by', 'required'),            array('email_id', 'email'),            array('created_by, modified_by', 'numerical', 'integerOnly' => true),            array('first_name, last_name, email_id', 'length', 'max' => 255),            array('mobile_no', 'length', 'max' => 100),            array('status', 'length', 'max' => 1),            array('username, email_id', 'unique'),            array('address, dojoin, dobirtrh, modified_at, username, password_hash, password_reset_token, temp_password, authorize', 'safe'),            // The following rule is used by search().            // @todo Please remove those attributes that should not be searched.            array('user_id, first_name, last_name, email_id, mobile_no, address, dojoin, dobirtrh, status, created_at, created_by, modified_at, modified_by', 'safe', 'on' => 'search'),        );    }    /**     * @return array relational rules.     */    public function relations() {        // NOTE: you may need to adjust the relation name and the related        // class name for the relations automatically generated below.        return array(        );    }    /**     * @return array customized attribute labels (name=>label)     */    public function attributeLabels() {        return array(            'user_id' => 'User',            'username' => 'User Name',            'password_hash' => 'Password',            'first_name' => 'First Name',            'last_name' => 'Last Name',            'email_id' => 'Email ID',            'mobile_no' => 'Mobile No',            'address' => 'Address',            'dojoin' => 'Date of Joining',            'dobirtrh' => 'Date of Birth',            'status' => 'Status',            'created_at' => 'Created At',            'created_by' => 'Created By',            'modified_at' => 'Modified At',            'modified_by' => 'Modified By',        );    }    /**     * Retrieves a list of models based on the current search/filter conditions.     *     * Typical usecase:     * - Initialize the model fields with values from filter form.     * - Execute this method to get CActiveDataProvider instance which will filter     * models according to data in model fields.     * - Pass data provider to CGridView, CListView or any similar widget.     *     * @return CActiveDataProvider the data provider that can return the models     * based on the search/filter conditions.     */    public function search() {        // @todo Please modify the following code to remove attributes that should not be searched.        $criteria = new CDbCriteria;        $criteria->compare('user_id', $this->user_id);        $criteria->compare('username', $this->username);        $criteria->compare('first_name', $this->first_name, true);        $criteria->compare('last_name', $this->last_name, true);        $criteria->compare('email_id', $this->email_id, true);        $criteria->compare('mobile_no', $this->mobile_no, true);        $criteria->compare('address', $this->address, true);        $criteria->compare('dojoin', $this->dojoin, true);        $criteria->compare('dobirtrh', $this->dobirtrh, true);        $criteria->compare('status', $this->status, true);        $criteria->compare('created_at', $this->created_at, true);        $criteria->compare('created_by', $this->created_by);        $criteria->compare('modified_at', $this->modified_at, true);        $criteria->compare('modified_by', $this->modified_by);        return new CActiveDataProvider($this, array(            'criteria' => $criteria,            'pagination' => array(                'pageSize' => PAGE_SIZE,            )        ));    }    /**     * Returns the static model of the specified AR class.     * Please note that you should have this exact method in all your CActiveRecord descendants!     * @param string $className active record class name.     * @return User the static model class     */    public static function model($className = __CLASS__) {        return parent::model($className);    }    public function dataProvider() {        return new CActiveDataProvider($this, array(            'pagination' => array(                'pageSize' => PAGE_SIZE,            )        ));    }    protected function beforeValidate() {        if ($this->isNewRecord) {            $this->created_at = new CDbExpression('NOW()');            $this->created_by = Yii::app()->user->id;        } else {            $this->modified_at = new CDbExpression('NOW()');            $this->modified_by = Yii::app()->user->id;        }        $this->dojoin = date('Y-m-d', strtotime($this->dojoin));        $this->dobirtrh = date('Y-m-d', strtotime($this->dobirtrh));        return parent::beforeValidate();    }    protected function beforeSave() {        if ($this->isNewRecord)            $this->generateCredentials();        $this->authorize = json_encode($this->authorize);        return parent::beforeSave();    }    protected function afterSave() {        if ($this->isNewRecord) {            $mail = new Sendmail;            $trans_array = array(                "{NAME}" => $this->first_name . ' ' . $this->last_name,                "{USERNAME}" => $this->username,                "{PASSWORD}" => $this->temp_password,                "{NEXTSTEPURL}" => Yii::app()->createAbsoluteUrl('/site/default/login'),            );            $message = $mail->getMessage('registration', $trans_array);            $mail->send($this->email_id, SITENAME . ": Login credentials", $message);        }        return parent::afterSave();    }    protected function afterFind() {        $this->dojoin = date(PHP_USER_DATE_FORMAT, strtotime($this->dojoin));        $this->dobirtrh = date(PHP_USER_DATE_FORMAT, strtotime($this->dobirtrh));        $this->authorize = json_decode($this->authorize);        return parent::beforeValidate();    }    public function generateCredentials() {        $this->username = $this->generateUsername();        $password = Myclass::getRandomString(self::PASSWORD_LENGTH);        $this->password_hash = Myclass::encrypt($password);        $this->temp_password = $password;    }    public function generateUsername() {        $str1 = strtolower(substr($this->first_name, 0, 1) . substr($this->last_name, 0, 1));        $count = self::model()->count() + 1;        $new_username = $str1 . str_pad($count, self::USERNAME_NUM_PAD, '0', STR_PAD_LEFT);        do {            $user = self::model()->findByAttributes(array('username' => $new_username));            if (!empty($user)) {                $check_username = $user->username;                $count++;                $new_username = $str1 . str_pad($count, self::USERNAME_NUM_PAD, '0', STR_PAD_LEFT);            } else {                break;            }        } while ($check_username != $new_username);        return $new_username;    }    public static function isPasswordResetTokenValid($token) {        if (empty($token)) {            return false;        }        $expire = Passwordresetform::PASSWORDRESETTOKENEXPIRE;        $parts = explode('_', $token);        $timestamp = (int) end($parts);        return $timestamp + $expire >= time();    }        public function generatePasswordResetToken() {        $this->password_reset_token = Myclass::getRandomString(20) . '_' . time();    }    public function removePasswordResetToken() {        $this->password_reset_token = '';    }}